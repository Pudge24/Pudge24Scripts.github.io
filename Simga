

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local soundName = "NotifySound1"
local soundId = "rbxassetid://654933978"
local soundVolume = 10

local replicatedStorage = game:GetService("ReplicatedStorage")
local existingSound = replicatedStorage:FindFirstChild(soundName)

if not existingSound then
    local sound = Instance.new("Sound")
    sound.Name = soundName
    sound.SoundId = soundId
    sound.Volume = soundVolume
    sound.Parent = replicatedStorage
end


local Window = Rayfield:CreateWindow({
    Name = "Sonic R-echarged",
    LoadingTitle = "Sonic script",
    LoadingSubtitle = "by Pudge24",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = "Pudger24Hub", -- Create a custom folder for your hub/game
       FileName = "SonicRCHRG"
    },
    Discord = {
       Enabled = true,
       Invite = "Mp9vjHBYC6", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = true, -- Set this to true to use our key system
    KeySettings = {
       Title = "Key in the discord",
       Subtitle = "Key System",
       Note = "discord.gg/Mp9vjHBYC6",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = true, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"https://raw.githubusercontent.com/Pudge24/Pudge24Scripts.github.io/refs/heads/main/README.md"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
 })

 local MainTab = Window:CreateTab("Main", nil) -- Title, Image
 local MainSection = MainTab:CreateSection("Main")

 
 local selectedSpeed = 16 -- Начальное значение скорости


 local Slider = MainTab:CreateSlider({
    Name = "WalkSpeed(To work properly enable LoopWS)",
    Range = {1, 350},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = selectedSpeed,
    Flag = "sliderws",
    Callback = function(Value)
         selectedSpeed = Value
         game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = selectedSpeed
    end,
 })

 local selectedJump = 50 -- Начальное значение jump
 local Slider = MainTab:CreateSlider({
    Name = "JumpPower Slider(LoopJP recommended)",
    Range = {1, 350},
    Increment = 1,
    Suffix = "JumpPower",
    CurrentValue = selectedJump,
    Flag = "sliderjp",
    Callback = function(Value)
        selectedJump = Value
         game.Players.LocalPlayer.Character.Humanoid.JumpPower = selectedJump
    end,
 })


local Input = MainTab:CreateInput({
   Name = "Walkspeed",
   PlaceholderText = "1-500",
   RemoveTextAfterFocusLost = true,
   Callback = function(Text)
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Text)
   end,
})

local Button = MainTab:CreateButton({
   Name = "Reset Speed",
   Callback = function()
   game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (24)
   end,
})


local Toggle = MainTab:CreateToggle({
    Name = "Loop WalkSpeed",
    CurrentValue = false,
    Flag = "toggles",
    Callback = function(CurrentValue)
       if CurrentValue then
          -- Start the loop
          _G.loops = true
          while _G.loops do
             game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = selectedSpeed
             wait(0.1) -- Adjust the wait time as needed
          end
       else
          -- Stop the loop
          _G.loops = false
       end
    end,
 })

 local Toggle = MainTab:CreateToggle({
    Name = "Loop JumpPower",
    CurrentValue = false,
    Flag = "togglej",
    Callback = function(CurrentValue)
       if CurrentValue then
          -- Start the loop
          _G.loopj = true
          while _G.loopj do
             game.Players.LocalPlayer.Character.Humanoid.JumpPower = selectedJump
             wait(0.1) -- Adjust the wait time as needed
          end
       else
          -- Stop the loop
          _G.loopj = false
       end
    end,
 })




local OtherSection = MainTab:CreateSection("Other")




local Button = MainTab:CreateButton({
   Name = "Infinite Yield",
   Callback = function()
   loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
   end,
})

local ExpTab = Window:CreateTab("Exploits", nil) -- Title, Image


local ohNumber1 = 1
game:GetService("ReplicatedStorage").AddRingEvent:FireServer(ohNumber1)

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohNumber1 = 1

game:GetService("ReplicatedStorage").AddLapEvent:FireServer(ohNumber1)

local Input = ExpTab:CreateInput({
    Name = "Get Rings",
    PlaceholderText = "1-999",
    RemoveTextAfterFocusLost = true,
    Callback = function(Text)
        local ohNumber1 = Text
        game:GetService("ReplicatedStorage").AddRingEvent:FireServer(ohNumber1)
    end,
 })

 local Input = ExpTab:CreateInput({
    Name = "Get Tokens(Медали)",
    PlaceholderText = "1-5",
    RemoveTextAfterFocusLost = true,
    Callback = function(Text)
        local ohNumber1 = Text
        game:GetService("ReplicatedStorage").AddTokenEvent:FireServer(ohNumber1)
    end,
 })

local Button = ExpTab:CreateButton({
    Name = "Give 1 lap",
    Callback = function ()
game:GetService("ReplicatedStorage").AddLapEvent:FireServer(ohNumber1)
    end
})

local Dropdown = ExpTab:CreateDropdown({
    Name = "Admin Character(Can't change while in the race)",
    Options = {"Shadow", "Rouge", "Cream"},
    CurrentOption = {"Choose Character"},
    MultipleOptions = false,
    Flag = nil, -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Options)
        if Options[1] == "Shadow" then      
local ohString1 = "Shadow"
game:GetService("ReplicatedStorage").CharacterEvent:FireServer(ohString1)
        elseif Options[1] == "Rouge" then
local ohString1 = "Rouge"
game:GetService("ReplicatedStorage").CharacterEvent:FireServer(ohString1)
        elseif Options[1] == "Cream" then
            local ohString1 = "Cream"
            game:GetService("ReplicatedStorage").CharacterEvent:FireServer(ohString1)
        end
    end,
})


local Button = ExpTab:CreateButton({
    Name = "Get all Emeralds Of Chaos",
    Callback = function ()
        local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local function teleportToChaosEmeralds()
    local chaosEmeralds = {}

    -- Ищем все MeshPart с названием "ChaosEmerald"
    for _, item in ipairs(Workspace:GetDescendants()) do
        if item:IsA("MeshPart") and item.Name == "ChaosEmerald" then
            table.insert(chaosEmeralds, item)
        end
    end

    -- Телепортируемся к каждому из найденных объектов с задержкой
    for _, emerald in ipairs(chaosEmeralds) do
        humanoidRootPart.CFrame = emerald.CFrame
        wait(0.5) -- Задержка в 1 секунду перед телепортацией к следующему
    end
end
teleportToChaosEmeralds()
    end
})

local Button = ExpTab:CreateButton({
    Name = "Get Rings Of Chaos",
    Callback = function ()
        local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local function teleportToChaosRings()
    local chaosRings = {}

    -- Ищем все MeshPart с названием "ChaosRing"
    for _, item in ipairs(Workspace:GetDescendants()) do
        if item:IsA("MeshPart") and item.Name == "ChaosRing" then
            table.insert(chaosRings, item)
        end
    end

    -- Телепортируемся к каждому из найденных объектов с задержкой
    for _, ring in ipairs(chaosRings) do
        humanoidRootPart.CFrame = ring.CFrame
        wait(0.5) -- Задержка в 1 секунду перед телепортацией к следующему
    end
end

teleportToChaosRings()

    end
})
